# -*- coding: utf-8 -*-
"""semcode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I_Jht5HIRZ3Cg8QOtJoOfOppgUnPRfTk
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.arima.model import ARIMA
from keras.models import Sequential
from keras.layers import LSTM, Dense
import matplotlib.pyplot as plt

# Load the data
df = pd.read_csv('ausdata.csv')

# Define the number of time steps for the LSTM model
n_steps = 3

# Define the Streamlit app
def main():
    st.title("Time Series Forecasting")
    model_selection = st.selectbox("Select a Model", ["ARIMA", "LSTM", "Linear Regression"])
    drug_selection = st.selectbox("Select a Drug", df['Variable'].unique())

    if st.button("Generate Forecast"):
        if model_selection == "ARIMA":
            arima_forecast(drug_selection)
        elif model_selection == "LSTM":
            lstm_forecast(drug_selection)
        elif model_selection == "Linear Regression":
            linear_regression_forecast(drug_selection)

# Function for ARIMA model forecast
def arima_forecast(drug_selection):
    # Get the selected drug data
    data = df[df['Variable'] == drug_selection]['Value'].tolist()

    # Fit ARIMA model
    model = ARIMA(data, order=(1, 1, 1))
    model_fit = model.fit()

    # Predict the next value in the time series
    forecast = model_fit.forecast()[0]

    # Plot actual vs predicted values
    fig, ax = plt.subplots()
    ax.plot(data, label='Actual')
    ax.plot([len(data)], [forecast], marker='o', markersize=8, label='Predicted')
    ax.set_title(drug_selection)
    ax.legend()
    st.pyplot(fig)

    # Display the forecasted value
    st.write("Next value in the time series:", forecast)

# Function for LSTM model forecast
def lstm_forecast(drug_selection):
    # Get the selected drug data
    drug_data = df[df['Variable'] == drug_selection]['Value'].tolist()

    # Split the data into input (X) and output (y) sequences
    X, y = [], []
    for i in range(len(drug_data) - n_steps):
        X.append(drug_data[i:i + n_steps])
        y.append(drug_data[i + n_steps])

    # Reshape the input data to be 3D for LSTM
    X = np.array(X).reshape(len(X), n_steps, 1)

    # Define the LSTM model
    model = Sequential()
    model.add(LSTM(50, activation='relu', input_shape=(n_steps, 1)))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')

    # Convert the output data y to a numpy array
    y = np.array(y)

    # Fit the LSTM model to the data
    model.fit(X, y, epochs=200, verbose=0)

    # Use the LSTM model to predict the next value in the time series
    last_sequence = np.array(drug_data[-n_steps:]).reshape(1, n_steps, 1)
    prediction = model.predict(last_sequence)

    # Append the predicted value to the original time series data
    drug_data.append(prediction[0][0])

    # Plot the original and predicted time series data
    fig, ax = plt.subplots()
    ax.plot(drug_data, label='Original')
    ax.plot(range(len(drug_data) - 1, len(drug_data) + 1), [drug_data[-2], prediction[0][0]], marker='o',
            color='red', label='Predicted')
    ax.set_title(drug_selection)
    ax.legend()
    st.pyplot(fig)

# Function for Linear Regression model forecast
def linear_regression_forecast(drug_selection):
    # Define the time series data
    data = df[df['Variable'] == drug_selection]['Value'].tolist()

    # Define the number of lagged values to include as input features
    n_lags = 2

    # Convert the data to a Pandas DataFrame
    df_data = pd.DataFrame(data, columns=['y'])

    # Add lagged values of the target variable as input features
    for i in range(1, n_lags + 1):
        df_data['lag_{}'.format(i)] = df_data['y'].shift(i)

    # Drop rows with missing values
    df_data.dropna(inplace=True)

    # Split the data into training and test sets
    train_data = df_data[:-1]
    test_data = df_data[-1:]

    # Create the linear regression model
    model = LinearRegression()

    # Fit the model to the training data
    X_train = train_data.drop('y', axis=1)
    y_train = train_data['y']
    model.fit(X_train, y_train)

    # Predict the next value in the time series
    X_test = test_data.drop('y', axis=1)
    forecast = model.predict(X_test)

    # Plot the time series data and the predicted value
    fig, ax = plt.subplots()
    ax.plot(df_data['y'], label='Actual')
    ax.plot(df_data.index[-1] + 1, forecast[0], 'ro', label='Predicted')
    ax.legend()
    ax.set_xlabel('Time')
    ax.set_ylabel('Value')
    st.pyplot(fig)

    st.write("Next value in the time series:", forecast[0])

# Run the app
if __name__ == "__main__":
    main()